# Прогресивний TypeScript - поступово, лише те що потрібно, з мінмімальними зусиллями.

Тисячі років тому, я писав [статтю про цікаві](https://dou.ua/forums/topic/35796/), на мою думку, можливості TypeScript. Я хотів показати що TS це не просто JsDoc на стероїдах, а щось набагато більше. Нажаль поруч із можливостями з'вилася і складність, навіть і надмірна. Тому сьогодні я хочу продемонструвати ще одну чудову якість цієї мови - її гнучкість, яка дозволяє вибудовувати систему саме такої суворості, яка потрібна у кожному конкретному випадку.

Стаття може бути цікава і початківцям, і тим хто думає про міграцію своєї кодової бази з JS на TS.

## Вихідні умови

План у мене простий. Беремо код на JS, адаптуємо його щоб запустити на TS, потім етапно його покращуємо за допомогою можливостей TypeScrip. Від вас - оцінити кількість зусиль та користь, яку ми за ці зусилля отримаємо. Єдине прохання - як будетете оцінювати, вважайте що над кодовою базою у нас працює хоча б 3 людини, а проект буде підтримуватися хоча б рік.

В якості прикладу я підготував наступну функцію (весь код доступний за [посиланням](https://github.com/Drag13/ts-easy)):

```javascript
async function fetchApi(url, options, mapper) {
  const fetchOptions = options ? { ...options } : {};

  if (fetchOptions.body && typeof fetchOptions.body !== "string") {
    fetchOptions.body = JSON.stringify(fetchOptions.body);
  }

  if (!fetchOptions.headeres) {
    fetchOptions.headers = {};
  }

  if (!fetchOptions.headers["Content-Type"]) {
    fetchOptions.headers["Content-Type"] = "application/json";
  }

  const response = await fetch(url, fetchOptions).then((x) => x.json());
  return typeof mapper === "function" ? mapper(response) : response;
}
```

Сама функція - це просто обгортка над `fetch` яка трохи спрощує роботу з ним - заголовки за замовчуванням, серіалізація, десеріалізація, мапінг, тощо. Я впевнений ви не один раз писали щось накшталт (той же axios, наприклад). Приклад може трохи штучний, але для демонстрації самого підходу буде як раз, особливо, враховуючи, що TS також вміє працювати і з просто JavaScript

Тепер давайте подивимось яку користь ми можемо отримати за допомогою TypeScript і скільки нам за це доведеться заплатити.

## Talk is cheap

Отже, у нас є робочий код, давайте його перепишемо на TS. Для того щоб не роздувати статтю зайвими деталями я пропущу частину про те, як підняти тестовий проект, але якщо потрібно - ось посилання на [репо](https://github.com/Drag13/ts-easy).

В першу чергу, давайте перейменуємо .js файл в .ts та спробуємо його виконати. Для таких штук я зазвичай використовую [ts-node](https://www.npmjs.com/package/ts-node), він дозволяє виконувати ts файли наче це звичаний JS. Ще можна взяти Deno, але зараз не про це.

Отже, запускаємо ts-node і ось перший результат, компілятор видає помилку:

> `Parameter 'url' implicitly has an 'any' type`

Помилка типова, виникає тому, що TS підтримує підхід, що явне, краще ніж не явне і за замовчуванням не дозволяє використовувати змінні якщо він не розуміє їх тип. Для того щоб цю помилку прибрати ми можемо або вказати тип явно (навіть той самий any), або налаштувати TS під наші потреби. Саме для цього існує файл [tsconfig.json](https://www.typescriptlang.org/tsconfig) - він відповідає за налаштування компілятора і дозволяє значно полегшити собі життя. Тому відкриваємо tsconfig (якщо у вас цього файлу немає, його можна створити за допомогою команди `npx tsc --init`) і встановлємо `noImplicitAny` в `false`\*.

Ще раз намагаємося виконати наш код - тепер все працює. Фактично, не змінючи сам код ми змогли запустити його за допомогою TS і тепер можемо помаленьку його покращувати (або погіршувати). Звичайно, у великому проекті таке щастя наврядчи трапиться, не буде, але по-перше, налаштувань в tsconfig багато і вони можуть дуже сильно спростити вам життя, а по-друге, ще раз нагадую, що TS може взагалі праюцвати з чистими JS файлами. Тож ми можемо переводити проект пофайлово.

\* `"noImplicitAny": false` вважається не дуже гарною практикою і я б не радив зловживати ним. Зазвичай краще поставити any самостійно, аби бачити де були втрачені типи

## Перші плоди

Отже, ми перетворили воду на вино, JS на TS, але наразі це призвело лише до погіршення ситуації. Ми додали складність в обмін на ніщо. Давайте це виправляти.

Почнемо з найпростішого - з першого аргументу метода fetch який має приймати URL нашого ресурсу.

Якщо ми будемо передавати туди просто якийсь рядок це може призвести до деяких проблем. По-перше, можна легко помилитися в написанні. По-друге - коли якийсь з ендпоінтів змінить свою адресу - потрібно буде бігати по всій кодовій базі та шукати всі місця, де цей ендпоінт використовується і немає гарантії що вас не відволічуть і ви не пропустите один з них. Тому, найчастіше, всі такі значення виносяться у константи - так їх і використовувати просто, і всі зміни зосереджені в одному місці.

Але і тут є маленький нюанс. Це потрібно пояснювати та й не все слідкують за стандартами (у світі рожевих поні - все і завжди, але ми ще не там) і може виникнути така ситуація коли хтось, помилково, знову буде використовувати просто `string`. Це спливе на CodeReview (або не спливе :)) і PR доведеться фіксити, що, очевидно, є витратою часу.

На щастя, цей маленький камінчик можна легко перекласти на плечі TypeScript. Для цього достатньо змінити об'єкт на `enum`, та вказати цей enum у якості типу:

```ts
enum API {
  USER = `http://localhost:4000/user`,
}
async function fetchApi(url: API);
```

Тепер наш URL це не просто довільний string, а елемент enum:

![](https://raw.githubusercontent.com/Drag13/ts-easy/master/src/2enum/Enum.PNG)

Якщо хтось випадково спробує використати звичайний string - TypeScript про це попередить, і білд просто впаде під час PR-у, або під час пушу, якщо ви користуєтесь хуками git-а для валідації коду.

## Типізація options

З першим аргументом розібралися, давайте спричинимо невідворотню шкоду і другому аргументу - об'єкту options.

Чи пам'ятаєте ви його структуру? Я, чесно кажучи, лише частково. Тому замість лізти в MDN, хотілося б мати працюючий інтелісенс, і, бажано, контроль типів. На щастя це не так і складно, оскільки ми можемо використовувати типи, які вже написані за нас, а саме тип `RequestInit` :

```ts
async function fetchApi(url: API, options: RequestInit);
```

Але з цим є проблема, навіть дві.

По-перше, як з'ясувалося, я допустив помилку в перевірці: `if (!options.headeres)`. В результаті цієї помилки, всі заголовки, які ми передавали у функцію видалялися і встановлювалися у дефолтні значення. Це досить неприємна помилка, яка може існувати в коді довгий час непоміченою (до першого кастомного хедера + дебаг). По-друге - в `RequestInit` тип body це string, а я хочу мати можливість передати туди об'єкт.

Першу проблему вирішити не складно, достатньо просто виправити помилку. З другою проблемою трохи складніше.

Найпростішим рішенням (і найгіршим) буде кожен раз, під час виклику fetchApi кастити body до any, наприклад ось так: `body: { id: 5 } as any`. Це спрацює, але код навіщо себе повторювати і захаращувати код зайвим? Тому є інший варіант - змінити тип `RequestInit` на щось краще. Наприклад ми можемо створити свій власний тип для того щоб спростити тип options, - прибрати зайві HTTTP глаголи, заборонити кастомні хедери, або що. Але зараз, писати свій тип - трохи суперечить ідеї статті. На щастя є золота середина - створення власного типу на основі вже існуючого.

```ts
// наслідуємо IAppRequestInit від RequestInit
interface IAppRequestInit extends RequestInit {
  // перевизначаємо body**
  body: any;
}

async function fetchApi(url, options?: IAppRequestInit, mapper?) {
  // вказуємо IAppRequestInit як тип для
  const fetchOptions = options ? { ...options } : ({} as IAppRequestInit);
}
```

\* За допомогою `.d.ts` файлів доступна модифікація глобальних типів. Так, наприклад, робить Vuex для створення типу глобального стора.

\*\* `body:any` не найкращий вибір, оскільки не дозволяє типізувати пейлоад. Краще використовувати [узагальнений інтерфейс](https://github.com/Drag13/ts-easy/blob/master/src/4options/generic-body.ts).

## Що у відповіді?

Тепер до більш цікавого. Що повертає нам fetchApi? Питання цікаве - треба дивитися в документацію або свагер, якщо такі є. А якщо документації немає то виникають проблеми. Більше того, навіть якщо документація є, інтелісенсу це зовсім не допомагає. Давайте ци виправимо.

Крок перший - узагальнюємо метод `fetchApi` і вказуємо тип повертаємого значення

```ts
async function fetchApi<T>(
  url: API,
  options: IAppRequestInit,
  mapper
): Promise<T>;
```

Крок другий - під час виклику функції - вказуємо тип, який ми очікуємо:

```ts
const user = await fetchApi<{ name: string }>(API.USER, { id: 3 });
```

Все, цього вже досить для того, щоб і Intellisense зрозумів тип об'єкту і TypeScript працював коректно:

Було:

![](https://raw.githubusercontent.com/Drag13/ts-easy/master/src/4return/without.PNG)

Стало:

![](https://raw.githubusercontent.com/Drag13/ts-easy/master/src/4return/with.PNG)

Але з цим підходом є дуже велике але (не робіть так).

## В замовлення поклали не те

Приклад вище - чудовий приклад як за допомогою TS можна вистрілити собі коліно. Давайте поглянемо на наступний приклад (зверніть увагу третій аргумент функції):

```ts
const user = await fetchApi<{ name: string }>(API.USER, { id: 3 }, () => null);
console.log(user.name);
```

З точки зори системи типів, все ОК, компілятор цей код пропустить. Але ж очевидно, що в runtime, код однозначно впаде, тому тепер, fetchApi завжди повертає null. Невже TypeScript такий "тупий", що не може це зрозуміти? Насправді ні, він може, але для цього нам потрібно йому хоча б не заважати. Насправді, якщо тип повертаємого об'єкту залежить від типу повертаємого мапером, то було б цілком логічно зв'язати ці типи. Натомість ми просто наказуємо TS вірити, що тип об'єкта який повертається з `fetchApi` буде саме таким як ми вказали. І він вірить...

Нащастя, виправити це дуже просто, достатньо вказати, що mapper повертає такий самий тип T.

```ts
async function fetchApi<T>(
  url: API,
  options: IAppRequestInit,
  mapper?: (x: unknown) => T
): Promise<T>;
```

Тепер TS виведе тип повертаємого значення автоматично, його навіть не потрібно буде вказувати (за умови що ви передаєте mapper).

```ts
const user = await fetchApi(API.USER, { id: 3 }, () => null);
// Object is possibly 'null'.ts(2531)
console.log(user.name);
```

## Підсумуємо

Отже, що ми зробили:

- Перевели "проект" з JS на TS не змінюючи сам код, лише за допомогою налаштувань TS
- Типізували URL - тепер що завгодно туди не передаш, хардкодити ендпоінти також не можна
- Додали Intellisense для об'єкта options
- Додали розумну типізацію результати функції fetchApi

При цьому всі зміни атомарні, ви можете використати всі, можете вибрати один будь-який. І саме цьому полягає та ідею яку я хотів продемонструвати в цій статті. TypeScript - потужний і гнучкий інструмент, який повністю підлаштовується під ваші вимоги. Хочете лайтову версію - вимикаємо всі strict правила, дозволяємо JS і вперед. Хочеться хардкору - викручуємо все на максимум. Хочете індивідуально - також будь-ласка.

І наостанок маленька gif-ка того що ми отримали:

![demo](https://raw.githubusercontent.com/Drag13/ts-easy/master/demo.gif)
