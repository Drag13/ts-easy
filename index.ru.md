# Как использовать TypeScript с минимумом усилий

Когда пишешь статью, в голове возникают самые разные сценарии о том, как она будет воспринята. Не знаю как у других авторов, но у меня такое происходит всегда, и чем ближе статья к завершению, тем сценарий обычно мрачнее.

Поэтому публикуя [прошлую статью о TS](https://dou.ua/forums/topic/35796/) я предполагал, что она может быть воспринята "не очень". Но все мои предположения крутились вокруг тривиальности примеров. А вот услышать, что TS не нужен в 2021, я как-то не ожидал. Но тут я увидел один очень интересный комментарий:

> Увы в TS очень сильно перегнули палку с диктатурой, а более мягкого инструмента посередине между jsdoc и TS, по сути, нет, если d.ts не считать. Мягких опциональных аннотаций типов было бы достаточно- тот же jsdoc, но в инлайн семантике. (by Dmitriy Mozgovoy)

А потом еще один:

> Фанаты TS часто забывают, что в большинстве баги типизации, что ловит TS, быстро находятся и без него. А меташума в коде добавляется много) (by Vlad N)

(На самом деле полезных комментариев было больше, я просто взял те, которые сработали первыми)

И понял, что похоже я таки перегнул палку. А почему? Да потому что оба комментария прекрасно демонстрируют что за деревьями не видно леса. Типы пишутся ради типов, усилий тратится много а примеры пользы выглядят не убедительно. Давайте попробуем зайти с другой стороны.

## Сначала все было хорошо

Сама идея проста. Давайте возьмем какой-то валидный код на JS и попробуем переписать его на TS. Задача - получить максимум пользы за минимум усилий. А вы оцените, что получилось в комментариях. Только давайте сразу договоримся - когда будете оценивать, исходите из того, что над кодом работает хотя бы 3 человека и это не одноразовый скрипт, его нужно потом поддерживать.

Для примера я подготовил следующую функцию, которую и буду улучшать:

```javascript
async function fetchApi(url, options, mapper) {
  options = options ?? {};

  if (options.body && typeof options.body !== "string") {
    options.body = JSON.stringify(options.body);
  }

  if (!options.headeres) {
    options.headers = {};
  }

  if (!options.headers["Content-Type"]) {
    options.headers["Content-Type"] = "application/json";
  }

  const response = await fetch(url, options).then((x) => x.json());
  return typeof mapper === "function" ? mapper(response) : response;
}
```

Тут все достаточно тривиально — это просто обертка над стандартным fetch которая упрощает с ним работу - заголовки по умолчанию, сериализация, дессериализация, трансформация. Сама задача не принципиальна, я хочу показать сам подход.

Теперь давайте посмотрим, какую пользу нам может принести TS и сколько нам придется за это заплатить.

## Talk is cheap

Итак, у нас есть код, он рабочий, будем его переписывать под TS. С целью уменьшения ентропии я опускаю раздел о том, как поднять тестовый проект, но если нужно - [вот ссылочка на рабочую репу](https://github.com/Drag13/ts-easy).

Первым делом, переименовываем .js в .ts и пробуем его выполнить (для таких эксперементов я обычно использую [ts-node](https://www.npmjs.com/package/ts-node), очень удобно выполнять скрипты без дополнительной конфигурации). И тут TS показывает всю свою "токсичность" - компилятор выдает ошибку `Parameter 'url' implicitly has an 'any' type` и простой, полностью валидный код падает. К счастью, TS штука достаточная гибкая, поэтому мы можем сходить в документацию и установить в `tsconfig.json` флаг `"noImplicitAny": false`\*. Теперь наш код выполняется успешно. Конечно, для запуска более сложного кода этого флага скорее всего не хватит, поэтому здесь я оставляю ссылку на [документацию](https://www.typescriptlang.org/tsconfig)

\* `"noImplicitAny": false` считается не очень хорошей практикой, так как вы больше не видите где TS потерял типы. Явное `any` лучше не явного `"noImplicitAny": false` но эти рассуждения выходят за рамки статьи.

## Типизируем result

Начнем с удобства. Если сейчас в редакторе написать `result.` то VsCode ничего нам не подскажет и это очевидно не удобно, - надо лезть в маппер и смотреть что он возвращает. Давайте это исправим:

Сначала мы делаем метод fetchApi обобщенным, добавляя `<T>`:

```ts
// Делаем fetchApi обобщенным, добавляя конструкцию <T>
// Указываем тип возвращаемого значения
async function fetchApi<T>(url, options, mapper): Promise<T>

// При вызове метода указываем ожидаемый тип
const result = await fetchApi<{ fullName: string }>
```

Все, этого уже достаточно для VsCode для того, что бы включился IntelliSense:

Было:

![](https://raw.githubusercontent.com/Drag13/ts-easy/master/src/2fetch/without.PNG)

Стало:

![](https://raw.githubusercontent.com/Drag13/ts-easy/master/src/2fetch/with.PNG)

Кроме этого, если мы забудем сделать await, TS подскажет что нам вернется Promise, а не ожидаемый объект:

Но стало ли лучше?

## Вокруг сплошной самообман

IntelliSense это конечно хорошо, но сейчас наш маппер может возвращать что угодно - `string`, null, NaN. И мы получим ситуацию даже хуже, чем она была до этого, потому что IntelliSense будет утверждать одно, а маппер будет возвращать совсем другое. Получать такие проблемы за свои же старания абсурдно,тем более что решается это очень просто - достаточно связать тип значения которое возвращает маппер и тип который мы ожидаем от `fetchApi`:

```ts
async function fetchApi<T>(url, options, mapper: (data: any) => T): Promise<T>;
```

Все, больше менять ничего не надо, этого уже достаточно. Теперь TS самостоятельно выведет тип вовзращаемого значения исходя из сигнатуры маппера. Нам даже не нужно явно указывать ожидаемый тип в методе `fetchApi`, хотя такая возможность все еще остается если вы хотите контролировать возвращаемый тип явно. 

Кстати, поскольку `mapper` не является опциональным, проверку на тип маппера можно убрать тем самым слегка упростив код, TS проследит что бы вы не забыли его передать. 

## И снова у матрицы сбой

Теперь посмотрим на сигнатуру функции `fetchApi`. Вы помните структуру options? Я - только частично. А хотелось бы чтобы TS нам и тут помогал, но описывать весь тип вручную явно противоречит идеи простоты. К счастью, мы можем просто переиспользовать существующие типы:

```ts
async function fetchApi<T>(
  url, 
  options: RequestInit, 
  mapper: (data: any) => T): Promise<T>;
```

Однако теперь возникла проблема, даже две. Во-первых, как выяснилось, я опечатался (интересно успел ли это кто-то заметить) в проверке ` if (!options.headeres)`. В результате этой опечатки все заголовки переписывались всегда, независимо от того передавали ли мы их или нет. Во-вторых, в типе `RequestInit` body это строка, а мы хотим передавать объект.

Первая проблема правится легко, достаточно исправить опечатку. А вот решений второй проблемы несколько. Самое очевидное - во время вызова `fetchApi` прикастить body к any: `body: { id: 5 } as any`. Это сработает, но так придется писать каждый раз при вызове `fetch`. Т.е. в перспективе это как раз сложный вариант. Второй вариант — это заменить тип `RequestInit` на свой самописный тип. Это может быть полезно, если вы хотите ограничить параметры, которые можно использовать во время запроса (например, запретить передавать заголовки вообще или ограничить доступные глаголы). Но писать свой тип - противоречит изначальным условиями статьи. К счастью, есть золотая середина - мы можем модфицировать\* чужой тип:

```ts
// Создаем новый интерфейс который наследуется от RequestInit
interface IAppRequestInit extends RequestInit {
  // Переопределяем тип body в any**
  body: any;
}
async function fetchApi<T>(
  url, 
  options: IAppRequestInit, 
  mapper: (data: any) => T): Promise<T> 
```

К тому же мы можем убрать строку с инициализацией `options` так как теперь TS будет самостоятельно\*\*\* следить за тем, чтобы туда был передан аргумент.

Вот и все, теперь все снова в порядке.

\* С помощью `.d.ts` файлов доступна глобальная модификация типа без создания промежуточного звена. Так, например, поступет Vuex что бы типизовать стор.

\*\* `body:any` не лучший выбор, так как закрывает нам дорогу к типизированному пейлоаду. Лучше использовать обобщенный интерфейс, пример [тут](https://github.com/Drag13/ts-easy/blob/master/src/4options/generic-body.ts).

\*\*\* Задача валидации сущностей, приходящих извне системы, все равно остается на разработчике. Это нужно понимать. Впрочем, TypeScript не имеет к этому никакого отношения.

## Ленивое API

Еще один интересный момент это URL, который мы используем что бы вызвать API. С одной стороны, мы все сделали красиво - вынесли все эндпоинты в константы. С другой стороны, новому человеку это все придется рассказывать, и потом проверять в PR-e. Но зачем тратить свои силы, если это легко автоматизировать? Тем более что решается это тривиально, достаточно заменить на объект на перечисление (enum)

```ts
// Заменяем объект на enum
enum API {
  USER = `http://localhost:4000/user`,
}
// Указываем тип для URL
async function fetchApi<T>(
  url: API, 
  options: IAppRequestInit, 
  mapper: (data: any) => T): Promise<T>;
```

Теперь эндпоинт это не произвольная строка, а элемент перечисления:

![](https://raw.githubusercontent.com/Drag13/ts-easy/master/src/5enum/Enum.PNG)

## В заключение

В заключение я просто покажу ролик о том, как выглядит вызов fetchApi после всех манипуляций (на запись этого ролика у меня ушло больше времени чем на описание всех типов в этой статье):

![demo](https://raw.githubusercontent.com/Drag13/ts-easy/master/demo.gif)

Конечно, можно пойти и дальше, например параметризировав `body` запроса, но это уже не принципиально, важен сам подход поэтапного улучшения когда. Когда мы не гонимся за типами как таковыми, а применяем их, четко понимая проблему, которую мы решаем. Большой плюс TypeScript в том, что он не следует принципу "все или ничего", а может быть использован именно таким способом, чтобы получить максимальную пользу за минимум усилий.

Спасибо за ваше внимание, надеюсь, что статья получилась полезной и мне удалось показать, что TS это не только меташум в коде, но и удобство.

Післямова. 
Нажаль, викласти свої думки українською, так щоб це влаштувало мене самого поки не вийшло. Проте спроби будуть продовжуватися, аж поки не вийде щось путнє. Сподіваюся, це займе не так багато часу.  